<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Unificato - Markdown + Disegno</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f3f2f1;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: #7c4dff;
            color: white;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        .title {
            font-size: 20px;
            font-weight: 600;
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-light {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .btn-light:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .toolbar {
            background: white;
            padding: 10px 20px;
            border-bottom: 1px solid #e1dfdd;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            z-index: 100;
        }

        .tool-group {
            display: flex;
            gap: 5px;
            align-items: center;
            padding: 0 10px;
            border-right: 1px solid #e1dfdd;
        }

        .tool-group:last-child {
            border-right: none;
        }

        .tool-btn {
            padding: 8px 12px;
            border: 1px solid #e1dfdd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
            user-select: none;
        }

        .tool-btn:hover {
            background: #f8f7f6;
            border-color: #c8c6c4;
        }

        .tool-btn.active {
            background: #7c4dff;
            color: white;
            border-color: #7c4dff;
        }

        .color-picker {
            width: 32px;
            height: 32px;
            border: 2px solid #e1dfdd;
            border-radius: 50%;
            cursor: pointer;
        }

        .stroke-slider {
            width: 80px;
        }

        .font-size-slider {
            width: 60px;
        }

        .main-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: white;
        }

        .canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
        }

        #unifiedCanvas {
            display: block;
            cursor: crosshair;
            background: white;
            position: absolute;
            top: 0;
            left: 0;
        }

        .text-input {
            position: absolute;
            border: 2px solid #7c4dff;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px;
            border-radius: 4px;
            outline: none;
            font-family: inherit;
            resize: none;
            min-width: 200px;
            min-height: 30px;
            z-index: 50;
            display: none;
        }

        .markdown-element {
            position: absolute;
            pointer-events: none;
            user-select: none;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .file-input {
            display: none;
        }

        /* Stili per il rendering del markdown */
        .md-h1 {
            font-size: 32px;
            font-weight: 700;
            color: #323130;
            margin: 8px 0;
        }

        .md-h2 {
            font-size: 24px;
            font-weight: 600;
            color: #323130;
            margin: 6px 0;
        }

        .md-h3 {
            font-size: 20px;
            font-weight: 600;
            color: #323130;
            margin: 4px 0;
        }

        .md-p {
            font-size: 16px;
            color: #605e5c;
            line-height: 1.6;
            margin: 4px 0;
        }

        .md-strong {
            font-weight: 700;
        }

        .md-em {
            font-style: italic;
        }

        .md-code {
            background: #f3f2f1;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
        }

        .md-ul {
            margin: 4px 0 4px 20px;
        }

        .md-li {
            margin: 2px 0;
            font-size: 16px;
            color: #605e5c;
        }

        .md-blockquote {
            border-left: 4px solid #7c4dff;
            padding-left: 15px;
            margin: 8px 0;
            font-style: italic;
            color: #605e5c;
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="title">üìù Canvas Unificato</div>
        <div class="header-actions">
            <button class="btn btn-light" onclick="exportData()">üíæ Esporta (.mia)</button>
            <label for="importFile" class="btn btn-light">üìÇ Importa</label>
            <input type="file" id="importFile" class="file-input" accept=".json,.mia" onchange="importData()">
        </div>
    </div>

    <div class="toolbar">
        <div class="tool-group">
            <span style="font-weight: 500; color: #605e5c;">Strumenti:</span>
            <button class="tool-btn" data-tool="text">üìù Testo MD</button>
            <button class="tool-btn active" data-tool="pen">‚úèÔ∏è Matita</button>
            <button class="tool-btn" data-tool="rectangle">‚ñ≠ Rettangolo</button>
            <button class="tool-btn" data-tool="circle">‚≠ï Cerchio</button>
            <button class="tool-btn" data-tool="arrow">‚û§ Freccia</button>
        </div>

        <div class="tool-group">
            <span style="font-size: 12px; color: #605e5c;">Colore:</span>
            <input type="color" class="color-picker" id="colorPicker" value="#000000">
        </div>

        <div class="tool-group">
            <span style="font-size: 12px; color: #605e5c;">Spessore:</span>
            <input type="range" class="stroke-slider" id="strokeWidth" min="1" max="20" value="3">
            <span id="strokeValue">3</span>
        </div>

        <div class="tool-group">
            <span style="font-size: 12px; color: #605e5c;">Testo:</span>
            <input type="range" class="font-size-slider" id="fontSize" min="12" max="48" value="16">
            <span id="fontValue">16</span>
        </div>

        <div class="tool-group">
            <button class="tool-btn" onclick="clearAll()" style="color: #d13438;">üóëÔ∏è Pulisci tutto</button>
            <button class="tool-btn" onclick="undo()">‚Ü∂ Annulla</button>
        </div>
    </div>

    <div class="main-container">
        <div class="canvas-container">
            <canvas id="unifiedCanvas"></canvas>
            <textarea class="text-input" id="textInput"></textarea>
        </div>
    </div>

    <script>
        // Variabili globali
        let canvas, ctx;
        let currentTool = 'pen';
        let isDrawing = false;
        let elements = [];
        let history = [];
        let currentElement = null;
        let startX, startY;
        let textInput;
        let editingTextId = null;

        // Inizializzazione
        document.addEventListener('DOMContentLoaded', function () {
            initializeCanvas();
            setupEventListeners();
        });

        function initializeCanvas() {
            canvas = document.getElementById('unifiedCanvas');
            ctx = canvas.getContext('2d');
            textInput = document.getElementById('textInput');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
            redrawAll();
        }

        function setupEventListeners() {
            // Tool selection
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', function () {
                    selectTool(this.dataset.tool);
                });
            });

            // Canvas events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('dblclick', handleDoubleClick);

            // Touch events
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);

            // Sliders
            const strokeWidth = document.getElementById('strokeWidth');
            const fontSize = document.getElementById('fontSize');

            strokeWidth.addEventListener('input', function () {
                document.getElementById('strokeValue').textContent = this.value;
            });

            fontSize.addEventListener('input', function () {
                document.getElementById('fontValue').textContent = this.value + 'px';
            });

            // Text input events
            textInput.addEventListener('blur', finishTextEdit);
            textInput.addEventListener('keydown', function (e) {
                if (e.key === 'Escape') {
                    finishTextEdit();
                } else if (e.key === 'Enter' && e.ctrlKey) {
                    finishTextEdit();
                }
                e.stopPropagation();
            });

            // Prevent context menu
            canvas.addEventListener('contextmenu', e => e.preventDefault());
        }

        function selectTool(tool) {
            document.querySelectorAll('.tool-btn.active').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
            currentTool = tool;

            canvas.style.cursor = tool === 'text' ? 'text' : 'crosshair';

            if (tool !== 'text') {
                hideTextInput();
            }
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }

        function handleMouseDown(e) {
            const pos = getMousePos(e);
            startDrawing(pos.x, pos.y);
        }

        function handleMouseMove(e) {
            if (!isDrawing) return;
            const pos = getMousePos(e);
            continueDrawing(pos.x, pos.y);
        }

        function handleMouseUp(e) {
            if (isDrawing) {
                const pos = getMousePos(e);
                finishDrawing(pos.x, pos.y);
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const pos = getTouchPos(e);
            startDrawing(pos.x, pos.y);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!isDrawing) return;
            const pos = getTouchPos(e);
            continueDrawing(pos.x, pos.y);
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            if (isDrawing) {
                finishDrawing();
            }
        }

        function handleDoubleClick(e) {
            const pos = getMousePos(e);
            const clickedElement = findElementAt(pos.x, pos.y);

            if (clickedElement && clickedElement.type === 'text') {
                startTextEdit(clickedElement);
            } else if (currentTool === 'text') {
                // Se siamo in modalit√† testo, crea nuovo testo anche con doppio click
                startTextInput(pos.x, pos.y);
            }
        }

        function startDrawing(x, y) {
            if (currentTool === 'text') {
                startTextInput(x, y);
                return;
            }

            isDrawing = true;
            startX = x;
            startY = y;

            const element = {
                id: Date.now() + Math.random(),
                type: currentTool,
                color: document.getElementById('colorPicker').value,
                strokeWidth: parseInt(document.getElementById('strokeWidth').value),
                x: x,
                y: y
            };

            if (currentTool === 'pen') {
                element.points = [{ x, y }];
            }

            currentElement = element;
            saveToHistory();
        }

        function continueDrawing(x, y) {
            if (!currentElement) return;

            if (currentTool === 'pen') {
                currentElement.points.push({ x, y });
            } else {
                currentElement.endX = x;
                currentElement.endY = y;
            }

            redrawAll();
            drawElement(currentElement, true);
        }

        function finishDrawing(x, y) {
            if (!isDrawing || !currentElement) return;

            isDrawing = false;

            if (x !== undefined && y !== undefined) {
                if (currentTool !== 'pen') {
                    currentElement.endX = x;
                    currentElement.endY = y;
                }
            }

            elements.push(currentElement);
            currentElement = null;
            redrawAll();
        }

        function startTextInput(x, y) {
            hideTextInput();

            textInput.style.left = x + 'px';
            textInput.style.top = y + 'px';
            textInput.style.fontSize = document.getElementById('fontSize').value + 'px';
            textInput.style.color = document.getElementById('colorPicker').value;
            textInput.style.display = 'block';
            textInput.value = '';
            textInput.focus();

            textInput.dataset.x = x;
            textInput.dataset.y = y;
            editingTextId = null;
        }

        function startTextEdit(element) {
            hideTextInput();

            textInput.style.left = element.x + 'px';
            textInput.style.top = element.y + 'px';
            textInput.style.fontSize = element.fontSize + 'px';
            textInput.style.color = element.color;
            textInput.style.display = 'block';
            textInput.value = element.text;
            textInput.focus();

            editingTextId = element.id;
        }

        function finishTextEdit() {
            const text = textInput.value.trim();
            if (!text) {
                hideTextInput();
                return;
            }

            const x = parseInt(textInput.dataset.x) || parseInt(textInput.style.left);
            const y = parseInt(textInput.dataset.y) || parseInt(textInput.style.top);
            const fontSize = parseInt(textInput.style.fontSize);
            const color = textInput.style.color || document.getElementById('colorPicker').value;

            if (editingTextId) {
                // Modifica elemento esistente
                const element = elements.find(el => el.id === editingTextId);
                if (element) {
                    element.text = text;
                    element.parsedContent = parseMarkdown(text);
                }
            } else {
                // Nuovo elemento
                const element = {
                    id: Date.now() + Math.random(),
                    type: 'text',
                    x: x,
                    y: y,
                    text: text,
                    fontSize: fontSize,
                    color: color,
                    parsedContent: parseMarkdown(text)
                };
                elements.push(element);
                saveToHistory();
            }

            hideTextInput();
            redrawAll();
        }

        function hideTextInput() {
            textInput.style.display = 'none';
            textInput.value = '';
            editingTextId = null;
        }

        function parseMarkdown(text) {
            // Parsing semplice del markdown per il rendering
            const lines = text.split('\n');
            const parsed = [];

            lines.forEach((line, index) => {
                let element = { text: line, style: 'p' };

                // Headers
                if (line.startsWith('# ')) {
                    element.text = line.substring(2);
                    element.style = 'h1';
                } else if (line.startsWith('## ')) {
                    element.text = line.substring(3);
                    element.style = 'h2';
                } else if (line.startsWith('### ')) {
                    element.text = line.substring(4);
                    element.style = 'h3';
                } else if (line.startsWith('- ') || line.startsWith('* ')) {
                    element.text = '‚Ä¢ ' + line.substring(2);
                    element.style = 'li';
                } else if (line.startsWith('> ')) {
                    element.text = line.substring(2);
                    element.style = 'blockquote';
                }

                // Inline formatting
                element.text = element.text
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/`(.*?)`/g, '<code>$1</code>');

                parsed.push(element);
            });

            return parsed;
        }

        function drawElement(element, isPreview = false) {
            ctx.save();

            switch (element.type) {
                case 'pen':
                    drawPen(element);
                    break;
                case 'rectangle':
                    drawRectangle(element, isPreview);
                    break;
                case 'circle':
                    drawCircle(element, isPreview);
                    break;
                case 'arrow':
                    drawArrow(element, isPreview);
                    break;
                case 'text':
                    drawText(element);
                    break;
            }

            ctx.restore();
        }

        function drawPen(element) {
            if (!element.points || element.points.length < 2) return;

            ctx.beginPath();
            ctx.strokeStyle = element.color;
            ctx.lineWidth = element.strokeWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.moveTo(element.points[0].x, element.points[0].y);
            for (let i = 1; i < element.points.length; i++) {
                ctx.lineTo(element.points[i].x, element.points[i].y);
            }
            ctx.stroke();
        }

        function drawRectangle(element, isPreview) {
            if (!isPreview && (!element.endX || !element.endY)) return;

            const endX = element.endX || element.x;
            const endY = element.endY || element.y;

            ctx.beginPath();
            ctx.strokeStyle = element.color;
            ctx.lineWidth = element.strokeWidth;
            ctx.rect(
                Math.min(element.x, endX),
                Math.min(element.y, endY),
                Math.abs(endX - element.x),
                Math.abs(endY - element.y)
            );
            ctx.stroke();
        }

        function drawCircle(element, isPreview) {
            if (!isPreview && (!element.endX || !element.endY)) return;

            const endX = element.endX || element.x;
            const endY = element.endY || element.y;
            const radius = Math.sqrt(Math.pow(endX - element.x, 2) + Math.pow(endY - element.y, 2));

            ctx.beginPath();
            ctx.strokeStyle = element.color;
            ctx.lineWidth = element.strokeWidth;
            ctx.arc(element.x, element.y, radius, 0, 2 * Math.PI);
            ctx.stroke();
        }

        function drawArrow(element, isPreview) {
            if (!isPreview && (!element.endX || !element.endY)) return;

            const endX = element.endX || element.x;
            const endY = element.endY || element.y;

            ctx.beginPath();
            ctx.strokeStyle = element.color;
            ctx.lineWidth = element.strokeWidth;
            ctx.lineCap = 'round';

            // Linea principale
            ctx.moveTo(element.x, element.y);
            ctx.lineTo(endX, endY);

            // Punta della freccia
            const headLength = 15;
            const angle = Math.atan2(endY - element.y, endX - element.x);

            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - headLength * Math.cos(angle - Math.PI / 6),
                endY - headLength * Math.sin(angle - Math.PI / 6)
            );
            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - headLength * Math.cos(angle + Math.PI / 6),
                endY - headLength * Math.sin(angle + Math.PI / 6)
            );

            ctx.stroke();
        }

        function drawText(element) {
            if (!element.parsedContent) return;

            let currentY = element.y;

            element.parsedContent.forEach(line => {
                ctx.fillStyle = element.color;
                let fontSize = element.fontSize;
                let fontWeight = 'normal';

                // Stili per i diversi elementi markdown
                switch (line.style) {
                    case 'h1':
                        fontSize = Math.max(element.fontSize * 2, 32);
                        fontWeight = '700';
                        break;
                    case 'h2':
                        fontSize = Math.max(element.fontSize * 1.5, 24);
                        fontWeight = '600';
                        break;
                    case 'h3':
                        fontSize = Math.max(element.fontSize * 1.2, 20);
                        fontWeight = '600';
                        break;
                    case 'li':
                        fontSize = element.fontSize;
                        break;
                    case 'blockquote':
                        ctx.fillStyle = '#605e5c';
                        fontSize = element.fontSize;
                        // Linea a sinistra per la citazione
                        ctx.fillRect(element.x - 5, currentY - fontSize, 3, fontSize + 5);
                        break;
                }

                ctx.font = `${fontWeight} ${fontSize}px 'Segoe UI', sans-serif`;

                // Rendering semplificato del testo (senza HTML)
                let displayText = line.text
                    .replace(/<strong>(.*?)<\/strong>/g, '$1')
                    .replace(/<em>(.*?)<\/em>/g, '$1')
                    .replace(/<code>(.*?)<\/code>/g, '$1');

                ctx.fillText(displayText, element.x, currentY);
                currentY += fontSize + 5;
            });
        }

        function findElementAt(x, y) {
            // Trova l'elemento pi√π in alto (ultimo disegnato) in una posizione
            for (let i = elements.length - 1; i >= 0; i--) {
                const element = elements[i];
                if (element.type === 'text') {
                    // Controllo approssimativo per il testo
                    const textHeight = element.fontSize * element.parsedContent.length + 10;
                    const textWidth = 200; // Approssimativo

                    if (x >= element.x && x <= element.x + textWidth &&
                        y >= element.y - element.fontSize && y <= element.y + textHeight) {
                        return element;
                    }
                }
            }
            return null;
        }

        function redrawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            elements.forEach(element => drawElement(element));
        }

        function clearAll() {
            if (confirm('Sei sicuro di voler cancellare tutto?')) {
                elements = [];
                history = [];
                hideTextInput();
                redrawAll();
            }
        }

        function saveToHistory() {
            history.push(JSON.parse(JSON.stringify(elements)));
            if (history.length > 20) {
                history.shift();
            }
        }

        function undo() {
            if (history.length > 0) {
                elements = history.pop();
                redrawAll();
            }
        }

        function exportData() {
            const data = {
                version: "3.0",
                type: "unified-canvas",
                timestamp: new Date().toISOString(),
                canvas: {
                    width: canvas.width,
                    height: canvas.height
                },
                elements: elements
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], {
                type: 'application/json'
            });

            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `canvas-unificato-${new Date().toISOString().slice(0, 16).replace(/:/g, '-')}.mia`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function exportMarkdown() {
            // Estrai tutto il testo e ordinalo per posizione Y
            const textElements = elements
                .filter(el => el.type === 'text')
                .sort((a, b) => a.y - b.y);

            let markdownContent = '';

            // Combina tutto il testo markdown
            textElements.forEach((element, index) => {
                if (index > 0) markdownContent += '\n\n';
                markdownContent += element.text;
            });

            // Crea un canvas per il rendering delle immagini
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvas.width;
            exportCanvas.height = canvas.height;
            const exportCtx = exportCanvas.getContext('2d');

            // Disegna solo gli elementi grafici (non il testo)
            exportCtx.fillStyle = 'white';
            exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

            elements.forEach(element => {
                if (element.type !== 'text') {
                    drawElementOnContext(exportCtx, element);
                }
            });

            // Converti il canvas in immagine
            const drawingDataURL = exportCanvas.toDataURL('image/png');

            // Crea il contenuto finale
            let finalContent = markdownContent;

            // Se ci sono elementi grafici, aggiungi l'immagine
            const hasDrawings = elements.some(el => el.type !== 'text');
            if (hasDrawings) {
                finalContent += '\n\n## Elementi Grafici\n\n';
                finalContent += '![Disegni e annotazioni](drawing.png)\n\n';
            }

            // Crea uno ZIP con markdown + immagine
            createMarkdownExport(finalContent, drawingDataURL, hasDrawings);
        }

        function drawElementOnContext(ctx, element) {
            ctx.save();

            switch (element.type) {
                case 'pen':
                    if (element.points && element.points.length >= 2) {
                        ctx.beginPath();
                        ctx.strokeStyle = element.color;
                        ctx.lineWidth = element.strokeWidth;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        ctx.moveTo(element.points[0].x, element.points[0].y);
                        for (let i = 1; i < element.points.length; i++) {
                            ctx.lineTo(element.points[i].x, element.points[i].y);
                        }
                        ctx.stroke();
                    }
                    break;

                case 'rectangle':
                    if (element.endX && element.endY) {
                        ctx.beginPath();
                        ctx.strokeStyle = element.color;
                        ctx.lineWidth = element.strokeWidth;
                        ctx.rect(
                            Math.min(element.x, element.endX),
                            Math.min(element.y, element.endY),
                            Math.abs(element.endX - element.x),
                            Math.abs(element.endY - element.y)
                        );
                        ctx.stroke();
                    }
                    break;

                case 'circle':
                    if (element.endX && element.endY) {
                        const radius = Math.sqrt(Math.pow(element.endX - element.x, 2) + Math.pow(element.endY - element.y, 2));
                        ctx.beginPath();
                        ctx.strokeStyle = element.color;
                        ctx.lineWidth = element.strokeWidth;
                        ctx.arc(element.x, element.y, radius, 0, 2 * Math.PI);
                        ctx.stroke();
                    }
                    break;

                case 'arrow':
                    if (element.endX && element.endY) {
                        ctx.beginPath();
                        ctx.strokeStyle = element.color;
                        ctx.lineWidth = element.strokeWidth;
                        ctx.lineCap = 'round';

                        // Linea principale
                        ctx.moveTo(element.x, element.y);
                        ctx.lineTo(element.endX, element.endY);

                        // Punta della freccia
                        const headLength = 15;
                        const angle = Math.atan2(element.endY - element.y, element.endX - element.x);

                        ctx.moveTo(element.endX, element.endY);
                        ctx.lineTo(
                            element.endX - headLength * Math.cos(angle - Math.PI / 6),
                            element.endY - headLength * Math.sin(angle - Math.PI / 6)
                        );
                        ctx.moveTo(element.endX, element.endY);
                        ctx.lineTo(
                            element.endX - headLength * Math.cos(angle + Math.PI / 6),
                            element.endY - headLength * Math.sin(angle + Math.PI / 6)
                        );

                        ctx.stroke();
                    }
                    break;
            }

            ctx.restore();
        }

        async function createMarkdownExport(markdownContent, drawingDataURL, hasDrawings) {
            // Per ora, creiamo un semplice download del markdown
            // In futuro si pu√≤ integrare JSZip per creare un vero ZIP

            let exportContent = markdownContent;

            if (hasDrawings) {
                // Aggiungi istruzioni per salvare l'immagine
                exportContent += '\n\n---\n';
                exportContent += '**Nota:** Salva anche l\'immagine allegata come "drawing.png" nella stessa cartella.\n\n';
                exportContent += `**Link immagine:** ${drawingDataURL.substring(0, 100)}...`;

                // Download dell'immagine separatamente
                const imageLink = document.createElement('a');
                imageLink.href = drawingDataURL;
                imageLink.download = 'drawing.png';
                document.body.appendChild(imageLink);
                imageLink.click();
                document.body.removeChild(imageLink);

                // Piccolo delay prima del markdown
                setTimeout(() => {
                    downloadMarkdown(exportContent);
                }, 500);
            } else {
                downloadMarkdown(exportContent);
            }
        }

        function downloadMarkdown(content) {
            const blob = new Blob([content], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `notes-${new Date().toISOString().slice(0, 16).replace(/:/g, '-')}.md`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        const file = document.getElementById('importFile').files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
            try {
                const data = JSON.parse(e.target.result);

                if (data.elements) {
                    elements = data.elements;
                    redrawAll();
                    alert('File importato con successo! ‚úÖ');
                } else {
                    alert('Formato file non riconosciuto.');
                }
            } catch (err) {
                alert('Errore nel leggere il file: ' + err.message);
            }
        };
        reader.readAsText(file);
        }
    </script>
</body>

</html>